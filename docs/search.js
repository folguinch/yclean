window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "yclean", "modulename": "yclean", "kind": "module", "doc": "<h1 id=\"yclean\">YCLEAN</h1>\n\n<p>An automatic CLEAN python module.\nThis is a modified version of the original <a href=\"https://zenodo.org/record/1216881\">YCLEAN</a>.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>To install YCLEAN and its dependencies run:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>git+https://github.com/folguinch/yclean.git<span class=\"w\"> </span>--user\n</code></pre>\n</div>\n\n<p>The current version has been tested with <code>python 3.8</code> and <code>casa 6.5.3</code>.\nAt the moment to run <code>tclean</code> in parallel it is necessary to install CASA from the <code>tar</code> file distribution (the <code>pip</code> command above should install the modular version of CASA too), and insert the CASA <code>bin</code> directory into your <code>PATH</code>, e.g.:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"nb\">export</span><span class=\"w\"> </span><span class=\"nv\">PATH</span><span class=\"o\">=</span><span class=\"s2\">&quot;/path/to/casa-6.5.3-28-py3.8/bin/:</span><span class=\"nv\">$PATH</span><span class=\"s2\">&quot;</span>\n</code></pre>\n</div>\n\n<p>Optional dependencies:</p>\n\n<ul>\n<li><code>psutil</code>: for additional feedback on the resources (memory) used during the mask making step.</li>\n</ul>\n\n<h2 id=\"running-yclean\">Running YCLEAN</h2>\n\n<p>YCLEAN can be used in 2 forms:</p>\n\n<h3 id=\"command-line-script\">Command line script</h3>\n\n<p>To execute YCLEAN from the command line run:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>python<span class=\"w\"> </span>-m<span class=\"w\"> </span>yclean.run_yclean<span class=\"w\"> </span>configfile<span class=\"w\"> </span>uvdata\n</code></pre>\n</div>\n\n<p>Additional command line options can be obtaining by running:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>python<span class=\"w\"> </span>-m<span class=\"w\"> </span>yclean.run_yclean<span class=\"w\"> </span>-h\n</code></pre>\n</div>\n\n<p>To execute YCLEAN from the command line a configuration file is necessary to obtain parameters for <code>tclean</code>, e.g.:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">[yclean]</span>\n<span class=\"na\">field</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">vis_field</span>\n<span class=\"na\">imsize</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">1000</span>\n<span class=\"na\">cell</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">0.1arcsec</span>\n<span class=\"na\">deconvolver</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">hogbom</span>\n<span class=\"na\">robust</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">0.5</span>\n<span class=\"na\">spws</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">0,1,2,3</span>\n<span class=\"na\">chanranges</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">0~1500</span>\n</code></pre>\n</div>\n\n<p>Note that most parameters are optional, if not present they take the default value from <code>tclean</code>.</p>\n\n<h3 id=\"modular-form\">Modular form</h3>\n\n<p>To run YCLEAN, import the <code>yclean</code> function into your script:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">yclean_parallel</span> <span class=\"kn\">import</span> <span class=\"n\">yclean</span>\n</code></pre>\n</div>\n\n<p>Read the <code>yclean_parallel.yclean</code> function docs to see its input parameters.</p>\n"}, {"fullname": "yclean.hacer_mascara", "modulename": "yclean.hacer_mascara", "kind": "module", "doc": "<p>Tasks for creating and writing masks.</p>\n"}, {"fullname": "yclean.hacer_mascara.IndexedMask", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask", "kind": "class", "doc": "<p>Store a mask by tracking <code>True</code> indices.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>indices:</strong>  structured array containing the indices along each axis.</li>\n<li><strong>shape:</strong>  shape of the mask.</li>\n<li><strong>origin:</strong>  indices origin.</li>\n<li><strong>is_shifted:</strong>  origin shifting status.</li>\n</ul>\n"}, {"fullname": "yclean.hacer_mascara.IndexedMask.__init__", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">origin</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">is_shifted</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "yclean.hacer_mascara.IndexedMask.from_array", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.from_array", "kind": "function", "doc": "<p>Create an indexed mask from an array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.indices_from_array", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.indices_from_array", "kind": "function", "doc": "<p>Get mask indices from mask array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;int32&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.get_origin", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.get_origin", "kind": "function", "doc": "<p>Get the origin of structured array of indices.</p>\n\n<p>The origin is defined as the lowest index along each axis (field) in\nthe array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.get_max", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.get_max", "kind": "function", "doc": "<p>Get the maximum along each field.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shift</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.update_origin", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.update_origin", "kind": "function", "doc": "<p>Find and update the <code>origin</code> from the current stored indices.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.shift_to_origin", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.shift_to_origin", "kind": "function", "doc": "<p>Shift indices so origin is zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.shift_back", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.shift_back", "kind": "function", "doc": "<p>Shift indices so origin is the origin back to original mask.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.update_to", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.update_to", "kind": "function", "doc": "<p>Replace the indices using input mask.</p>\n\n<p>If <code>shift_back</code> is <code>True</code> then the indices derived from <code>mask</code> are\nshifted using the stored <code>origin</code>, i.e. it assumes the input mask has\nthe same origin as the stored indices and that these were shifted so\norigin is zero.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">shift_back</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.merge_with", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.merge_with", "kind": "function", "doc": "<p>Union of 2 masks.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">yclean</span><span class=\"o\">.</span><span class=\"n\">hacer_mascara</span><span class=\"o\">.</span><span class=\"n\">IndexedMask</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.minimal_mask", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.minimal_mask", "kind": "function", "doc": "<p>Return a mask with the minimum shape containg all valid point.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">shift_to_origin</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.to_array", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.to_array", "kind": "function", "doc": "<p>Build a mask array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.is_in", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.is_in", "kind": "function", "doc": "<p>Is position in mask?</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">val</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.IndexedMask.mask_from_position", "modulename": "yclean.hacer_mascara", "qualname": "IndexedMask.mask_from_position", "kind": "function", "doc": "<p>Recover the mask at a given position.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">pix</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.write_mask", "modulename": "yclean.hacer_mascara", "qualname": "write_mask", "kind": "function", "doc": "<p>Write mask to disk.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  mask array</li>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>output:</strong>  file name of the CASA mask.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">cube</span><span class=\"p\">:</span> <span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span>,</span><span class=\"param\">\t<span class=\"n\">output</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.remove_small_masks", "modulename": "yclean.hacer_mascara", "qualname": "remove_small_masks", "kind": "function", "doc": "<p>Remove small masks pieces.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  mask array.</li>\n<li><strong>beam_area:</strong>  beam area in pixels.</li>\n<li><strong>beam_fraction:</strong>  fraction of the beam area for small masks.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>An <code>IndexedMask</code> object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">yclean</span><span class=\"o\">.</span><span class=\"n\">hacer_mascara</span><span class=\"o\">.</span><span class=\"n\">IndexedMask</span>,</span><span class=\"param\">\t<span class=\"n\">beam_area</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">beam_fraction</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">bound</span> <span class=\"n\">method</span> <span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">post</span> <span class=\"n\">of</span> <span class=\"o\">&lt;</span><span class=\"n\">casatools</span><span class=\"o\">.</span><span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">logsink</span> <span class=\"nb\">object</span> <span class=\"n\">at</span> <span class=\"mh\">0x7fb51ca6e0a0</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">yclean</span><span class=\"o\">.</span><span class=\"n\">hacer_mascara</span><span class=\"o\">.</span><span class=\"n\">IndexedMask</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.make_threshold_mask", "modulename": "yclean.hacer_mascara", "qualname": "make_threshold_mask", "kind": "function", "doc": "<p>Creates a mask from flux threshold.</p>\n\n<p>The <code>residual</code> image is used if <code>use_residual=True</code>, which is the default.\nOtherwise, it takes <code>cube</code> image. It calculates a mask with 1s over the\n<code>mask_threshold</code>. The task will remove connected components smaller than a\nfraction (could be &gt; 1) of the beam size. Lets call this mask <code>MM</code>. If\nexisting image(s) name(s) is(are) given in <code>previous_mask</code>, the task will\nredefine <code>MM</code> by combining it, using a logical <code>OR</code>, with that mask.  Mask\n<code>MM</code> is recorded with the the name <code>output_mask</code>.</p>\n\n<p>The mask can be dilated in all directions (spatial and spectral). The\nnumber of iterations to dilate is given by the value of the input parameter\n<code>dilate</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cube:</strong>  image spectral cube.</li>\n<li><strong>residual:</strong>  residual spectral cube.</li>\n<li><strong>pbmap:</strong>  primary beam spectral cube.</li>\n<li><strong>mask_threshold:</strong>  threshold level.</li>\n<li><strong>output_mask:</strong>  output mask file name.</li>\n<li><strong>previous_mask:</strong>  optional; mask to combine with the new mask.</li>\n<li><strong>beam_fraction:</strong>  optional; fraction of the beam to reject small masks.</li>\n<li><strong>dilate:</strong>  optional; number of dilation iterations.</li>\n<li><strong>use_residual:</strong>  optional; use residual image?</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A binary mask.\n  A dictionary with mask statistics.</p>\n</blockquote>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>Version 28 Dic 2017.\n  Updated to python 3 on May 2021.\n  Improved on June 2022.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cube</span><span class=\"p\">:</span> <span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span>,</span><span class=\"param\">\t<span class=\"n\">residual</span><span class=\"p\">:</span> <span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span>,</span><span class=\"param\">\t<span class=\"n\">pbmap</span><span class=\"p\">:</span> <span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span>,</span><span class=\"param\">\t<span class=\"n\">mask_threshold</span><span class=\"p\">:</span> <span class=\"n\">astropy</span><span class=\"o\">.</span><span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">quantity</span><span class=\"o\">.</span><span class=\"n\">Quantity</span>,</span><span class=\"param\">\t<span class=\"n\">output_mask</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">previous_mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">yclean</span><span class=\"o\">.</span><span class=\"n\">hacer_mascara</span><span class=\"o\">.</span><span class=\"n\">IndexedMask</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">beam_fraction</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">dilate</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_residual</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">bound</span> <span class=\"n\">method</span> <span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">post</span> <span class=\"n\">of</span> <span class=\"o\">&lt;</span><span class=\"n\">casatools</span><span class=\"o\">.</span><span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">logsink</span> <span class=\"nb\">object</span> <span class=\"n\">at</span> <span class=\"mh\">0x7fb51ca6e0a0</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">yclean</span><span class=\"o\">.</span><span class=\"n\">hacer_mascara</span><span class=\"o\">.</span><span class=\"n\">IndexedMask</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.hacer_mascara.open_mask", "modulename": "yclean.hacer_mascara", "qualname": "open_mask", "kind": "function", "doc": "<p>Open a mask and load the array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mask_name</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_tclean_parallel", "modulename": "yclean.run_tclean_parallel", "kind": "module", "doc": "<p>Script to run tclean in parallel with mpicasa.</p>\n"}, {"fullname": "yclean.run_tclean_parallel.main", "modulename": "yclean.run_tclean_parallel", "qualname": "main", "kind": "function", "doc": "<p>Run tclean.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_yclean", "modulename": "yclean.run_yclean", "kind": "module", "doc": "<p>Program to run YCLEAN.</p>\n"}, {"fullname": "yclean.run_yclean.split_option", "modulename": "yclean.run_yclean", "qualname": "split_option", "kind": "function", "doc": "<p>Split values from configuration option value.</p>\n\n<p>The program will use the <code>,</code> separator first to split the data, if\nunseccessful it will use space.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cfg:</strong>  configuration parser proxy.</li>\n<li><strong>option:</strong>  option.</li>\n<li><strong>ignore_sep:</strong>  optional; ignore separator (use if \",\" is allowed in value).</li>\n<li><strong>dtype:</strong>  optional; map values to dtype.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A list with the values under <code>section</code>, <code>option</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cfg</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Config</span>,</span><span class=\"param\">\t<span class=\"n\">option</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">ignore_sep</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">()</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_yclean.get_nchans", "modulename": "yclean.run_yclean", "qualname": "get_nchans", "kind": "function", "doc": "<p>Determine the number of channels from a channel range.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>chanrange:</strong>  channel range.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The number of channels in the range.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">chanrange</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_yclean.fill_window", "modulename": "yclean.run_yclean", "qualname": "fill_window", "kind": "function", "doc": "<p>Fill information for each channel window/range.</p>\n\n<p>Each element of the list contains the information for each channel range.\nThe are stored are:</p>\n\n<ul>\n<li><code>basename</code>: base name to keep track of results.</li>\n<li><code>name</code>: complete name.</li>\n<li><code>freq</code>: rest frequency.</li>\n<li><code>spw</code>: nominal spw value.</li>\n<li><code>spw_val</code>: <code>spw</code> value for <code>tclean</code>.</li>\n<li><code>width</code>: the <code>width</code> parameter for <code>tclean</code>.</li>\n<li><code>start</code>: the <code>start</code> parameter for <code>tclean</code>.</li>\n<li><code>nchan</code>: the <code>nchan</code> parameter for <code>tclean</code>.</li>\n</ul>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>chanranges:</strong>  list with the channel ranges to split the spw.</li>\n<li><strong>kwargs:</strong>  additional window information.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A list with the window information.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">chanranges</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_yclean.fill_names", "modulename": "yclean.run_yclean", "qualname": "fill_names", "kind": "function", "doc": "<p>Create base names for spws.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>basenames:</strong>  base name list.</li>\n<li><strong>spws:</strong>  spw list.</li>\n<li><strong>default:</strong>  optional; default name.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A list with names for each spw.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basenames</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">spws</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span>, </span><span class=\"param\"><span class=\"n\">default</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;spw&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_yclean.match_length", "modulename": "yclean.run_yclean", "qualname": "match_length", "kind": "function", "doc": "<p>Read values from configuration and match the length to <code>len(match)</code>.</p>\n\n<p>The filler function <code>fillerfn</code> should receive 2 inputs: a value and\n<code>match</code>; and return a list with length equal to <code>len(match)</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cfg:</strong>  configuration parser proxy.</li>\n<li><strong>option:</strong>  parser option.</li>\n<li><strong>match:</strong>  sequence to match the length to.</li>\n<li><strong>filler:</strong>  optional; filler value in case option was not set.</li>\n<li><strong>fillerfn:</strong>  optional; filling function in case option was not set.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cfg</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Config</span>,</span><span class=\"param\">\t<span class=\"n\">option</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">match</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span>,</span><span class=\"param\">\t<span class=\"n\">filler</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">fillerfn</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">print</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_yclean.get_windows", "modulename": "yclean.run_yclean", "qualname": "get_windows", "kind": "function", "doc": "<p>Define parameters for each spw.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vis:</strong>  visibility file.</li>\n<li><strong>cfg:</strong>  configuration parser proxy.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A list with the information for cleaning each spw.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vis</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">cfg</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">Config</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">print</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_yclean.crop_spectral_axis", "modulename": "yclean.run_yclean", "qualname": "crop_spectral_axis", "kind": "function", "doc": "<p>Crop image along the spectral axis.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>img:</strong>  CASA image object.</li>\n<li><strong>chans:</strong>  channel range.</li>\n<li><strong>outfile:</strong>  output image file.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span><span class=\"p\">:</span> <span class=\"n\">casatools</span><span class=\"o\">.</span><span class=\"n\">image</span><span class=\"o\">.</span><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">chans</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">outfile</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_yclean.join_cubes", "modulename": "yclean.run_yclean", "qualname": "join_cubes", "kind": "function", "doc": "<p>Join cubes at specific channels.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inputs:</strong>  input cubes to join.</li>\n<li><strong>output:</strong>  file name.</li>\n<li><strong>channels:</strong>  channel ranges for spectral cropping.</li>\n<li><strong>resume:</strong>  optional; resume calculations?</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">inputs</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">output</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">channels</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">resume</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">print</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.run_yclean.run_yclean", "modulename": "yclean.run_yclean", "qualname": "run_yclean", "kind": "function", "doc": "<p>Program main.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>args:</strong>  command line args.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.utils", "modulename": "yclean.utils", "kind": "module", "doc": "<p>Common utilities.</p>\n"}, {"fullname": "yclean.utils.load_images", "modulename": "yclean.utils", "qualname": "load_images", "kind": "function", "doc": "<p>Load images into <code>SpectralCube</code> objects.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>imagename:</strong>  name of the image (ending with <code>.image</code>).</li>\n<li><strong>load:</strong>  optional; type of files to load.</li>\n<li><strong>export_to:</strong>  optional; same as <code>imagename</code> but to write FITS to.</li>\n<li><strong>import_format:</strong>  optional; format of the input images.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A tuple with the images in the same order as <code>load</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">imagename</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">load</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;image&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;residual&#39;</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">export_to</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">import_format</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;casa&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">bound</span> <span class=\"n\">method</span> <span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">post</span> <span class=\"n\">of</span> <span class=\"o\">&lt;</span><span class=\"n\">casatools</span><span class=\"o\">.</span><span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">logsink</span> <span class=\"nb\">object</span> <span class=\"n\">at</span> <span class=\"mh\">0x7fb51ca6e0a0</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.utils.second_max_local", "modulename": "yclean.utils", "qualname": "second_max_local", "kind": "function", "doc": "<p>Determine the psf secondary lobe level.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">psf</span><span class=\"p\">:</span> <span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "yclean.utils.tclean_parallel", "modulename": "yclean.utils", "qualname": "tclean_parallel", "kind": "function", "doc": "<p>Run <code>tclean</code> in parallel.</p>\n\n<p>If the number of processes (<code>nproc</code>) is 1, then it is run in a single\nprocessor. The environmental variable <code>MPICASA</code> is used to run the code,\notherwise it will use the <code>mpicasa</code> and <code>casa</code> available in the system.</p>\n\n<p>A new logging file is created by <code>mpicasa</code>. This is located in the same\ndirectory where the program is executed.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vis:</strong>  measurement set.</li>\n<li><strong>imagename:</strong>  image file name.</li>\n<li><strong>nproc:</strong>  number of processes.</li>\n<li><strong>tclean_args:</strong>  other arguments for tclean.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vis</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">imagename</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">nproc</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">tclean_args</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">print</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "yclean.utils.common_beam_cube", "modulename": "yclean.utils", "qualname": "common_beam_cube", "kind": "function", "doc": "<p>Convolve the cube to a single beam and calsulates the minimal subcube.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cube:</strong>  the spectral cube.</li>\n<li><strong>filename:</strong>  output FITS file.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cube</span><span class=\"p\">:</span> <span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">bound</span> <span class=\"n\">method</span> <span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">post</span> <span class=\"n\">of</span> <span class=\"o\">&lt;</span><span class=\"n\">casatools</span><span class=\"o\">.</span><span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">logsink</span> <span class=\"nb\">object</span> <span class=\"n\">at</span> <span class=\"mh\">0x7fb51ca6e0a0</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.utils.pb_crop_fits", "modulename": "yclean.utils", "qualname": "pb_crop_fits", "kind": "function", "doc": "<p>Crop a cube from a pb level.</p>\n\n<p>This function assumes all images have the same dimenssions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pbmap:</strong>  the pb map.</li>\n<li><strong>level:</strong>  pb cut level.</li>\n<li><strong>fitsbase:</strong>  the base filename for the fits file (without <code>fits</code> extension).</li>\n<li><strong>load:</strong>  images to crop.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pbmap</span><span class=\"p\">:</span> <span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span>,</span><span class=\"param\">\t<span class=\"n\">level</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">fitsbase</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">load</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">print</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.utils.store_stats", "modulename": "yclean.utils", "qualname": "store_stats", "kind": "function", "doc": "<p>Write statistics to disk.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">stats</span><span class=\"p\">:</span> <span class=\"n\">Dict</span>,</span><span class=\"param\">\t<span class=\"n\">fmts</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.yclean_parallel", "modulename": "yclean.yclean_parallel", "kind": "module", "doc": "<p>Automasking routine for ALMA cube CLEANing.</p>\n"}, {"fullname": "yclean.yclean_parallel.get_stats", "modulename": "yclean.yclean_parallel", "qualname": "get_stats", "kind": "function", "doc": "<p>Calculate image statistics (rms, max, limits).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cube:</strong>  image spectral cube.</li>\n<li><strong>residual:</strong>  residual spectral cube.</li>\n<li><strong>secondary_lobe_level:</strong>  secondary lobe level.</li>\n<li><strong>pbmask:</strong>  optional; compute maximum only on values in mask.</li>\n<li><strong>planes:</strong>  optional; channel percentiles where statistics are measured.</li>\n<li><strong>ignore_borders:</strong>  optional; ignore this number of border channels.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The rms value calculated from the input planes.\n  Updated maximum of the residual.\n  Limit level SNR.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cube</span><span class=\"p\">:</span> <span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span>,</span><span class=\"param\">\t<span class=\"n\">residual</span><span class=\"p\">:</span> <span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span>,</span><span class=\"param\">\t<span class=\"n\">secondary_lobe_level</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">pbmask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">spectral_cube</span><span class=\"o\">.</span><span class=\"n\">SpectralCube</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">planes</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">ignore_borders</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">print</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.yclean_parallel.plot_yclean_step", "modulename": "yclean.yclean_parallel", "qualname": "plot_yclean_step", "kind": "function", "doc": "<p>Plot spectra from a <code>yclean</code> step.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cube_spec:</strong>  spectrum from the image.</li>\n<li><strong>mask_spec:</strong>  mask slice.</li>\n<li><strong>res_spec:</strong>  spectrum from the residual.</li>\n<li><strong>dirty_spec:</strong>  spectrum from dirty image.</li>\n<li><strong>plot_name:</strong>  figure name.</li>\n<li><strong>threshold:</strong>  optional; plot the threshold value.</li>\n<li><strong>masklevel:</strong>  optional; plot the mask threshold value.</li>\n<li><strong>unit:</strong>  optional; intensity unit.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cube_spec</span><span class=\"p\">:</span> <span class=\"n\">astropy</span><span class=\"o\">.</span><span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">quantity</span><span class=\"o\">.</span><span class=\"n\">Quantity</span>,</span><span class=\"param\">\t<span class=\"n\">mask_spec</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">res_spec</span><span class=\"p\">:</span> <span class=\"n\">astropy</span><span class=\"o\">.</span><span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">quantity</span><span class=\"o\">.</span><span class=\"n\">Quantity</span>,</span><span class=\"param\">\t<span class=\"n\">dirty_spec</span><span class=\"p\">:</span> <span class=\"n\">astropy</span><span class=\"o\">.</span><span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">quantity</span><span class=\"o\">.</span><span class=\"n\">Quantity</span>,</span><span class=\"param\">\t<span class=\"n\">plot_name</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">masklevel</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">astropy</span><span class=\"o\">.</span><span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">quantity</span><span class=\"o\">.</span><span class=\"n\">Quantity</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">astropy</span><span class=\"o\">.</span><span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Unit</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.yclean_parallel.get_threshold", "modulename": "yclean.yclean_parallel", "qualname": "get_threshold", "kind": "function", "doc": "<p>Calculate the <code>tclean</code> threshold.</p>\n\n<p>We use an arctan function normalized so a secondary lobe level of 0.2 will\nresult in a threshold of <code>0.4*residual_max</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>secondary_lobe_level:</strong>  secondary lobe level.</li>\n<li><strong>residual_max:</strong>  maximum of the residual.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">secondary_lobe_level</span><span class=\"p\">:</span> <span class=\"n\">astropy</span><span class=\"o\">.</span><span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">quantity</span><span class=\"o\">.</span><span class=\"n\">Quantity</span>,</span><span class=\"param\">\t<span class=\"n\">residual_max</span><span class=\"p\">:</span> <span class=\"n\">astropy</span><span class=\"o\">.</span><span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">quantity</span><span class=\"o\">.</span><span class=\"n\">Quantity</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">bound</span> <span class=\"n\">method</span> <span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">post</span> <span class=\"n\">of</span> <span class=\"o\">&lt;</span><span class=\"n\">casatools</span><span class=\"o\">.</span><span class=\"n\">logsink</span><span class=\"o\">.</span><span class=\"n\">logsink</span> <span class=\"nb\">object</span> <span class=\"n\">at</span> <span class=\"mh\">0x7fb51ca6e0a0</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.yclean_parallel.resume_from_stats", "modulename": "yclean.yclean_parallel", "qualname": "resume_from_stats", "kind": "function", "doc": "<p>Load values resuming values from stats file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>stats_file:</strong>  file with the statistics table.</li>\n<li><strong>mask_dir:</strong>  directory with the masks.</li>\n<li><strong>file_root:</strong>  mask name root name.</li>\n<li><strong>iter_limits:</strong>  optional; maximum number of iterations.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">stats_file</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">mask_dir</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">file_root</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">iter_limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "yclean.yclean_parallel.yclean", "modulename": "yclean.yclean_parallel", "qualname": "yclean", "kind": "function", "doc": "<p>Automatic CLEANing.</p>\n\n<p>The data is cleaned with an incremental mask for each iteration.\nThe maximum number of iterations can be controled with the <code>iter_limit</code>\nparameter. The <code>tclean</code> threshold is determined from the previous iteration\n(starting with a dirty cube). The <code>iter_limit</code> parameter allows to control\nthe minimum threshold allowed: <code>threshold = 2 * min_limit_level * rms</code>.</p>\n\n<p>The <code>pb_crop_level</code> parameter is used to determine the limits where the\nimage cube will be cropped after the final iteration.</p>\n\n<p>The <code>peak_tol</code> determines if the peak should be scaled down. This may\nbe triggered when the residual peak is outside the mask and it did not\nchange in value (within the tolerance) after the tclean iteration.\nThe tolerance is defined as <code>peak_tol * rms</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vis:</strong>  visibility filename.</li>\n<li><strong>imagename:</strong>  imagename base name.</li>\n<li><strong>nproc:</strong>  optional; number of processes for parallel processing.</li>\n<li><strong>min_limit_level:</strong>  optional; minimum SNR limit level.</li>\n<li><strong>iter_limit:</strong>  optional; maximum number of yclean iterations.</li>\n<li><strong>common_beam:</strong>  optional; calculate common beam cube?</li>\n<li><strong>resume:</strong>  optional; resume computations.</li>\n<li><strong>peak_tol:</strong>  optional; rms factor to trigger a peak correction.</li>\n<li><strong>full:</strong>  optional; store intermediate steps images and masks?</li>\n<li><strong>pbcor:</strong>  optional; compute the pbcor image after the last clean.</li>\n<li><strong>pb_crop_level:</strong>  optional; crop the final cube down to the given pb limit.</li>\n<li><strong>spectrum_at:</strong>  optional; plot results using a spectrum at this pixel.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n<li><strong>tclean_args:</strong>  arguments for <code>tclean</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The path of the final image.\n  The path of the final image converted to FITS.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vis</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">imagename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">nproc</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">min_limit_level</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.5</span>,</span><span class=\"param\">\t<span class=\"n\">iter_limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">common_beam</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">resume</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">peak_tol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">full</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">pbcor</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">pb_crop_level</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">spectrum_at</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">print</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">tclean_args</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();